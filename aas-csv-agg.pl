#!/usr/bin/env perl

use warnings;
use strict;
use Data::Dumper;
use IO::File;

# aggregate normalized AAS values
# get a sum of AAS per minute across all databases


# use the first file seen to populate the times array
# accordingly the first file should have the earliest time seen

# aggregate values from files generated by aas-csv-by-instance.[sh|sql]
#
# aas-csv-agg.pl csv-aas-by-instance/*.csv > aas-by-instance.csv
#

my @files=@ARGV;
#print Dumper(\@files);

# get all timestamps
# easiest from shell

qx%cut -f1 -d, csv-aas-by-instance/* | sort | grep -v timestamp > times.csv%;

my $timesFile='times.csv';

my $fh= IO::File->new();

$fh->open($timesFile,'<',) or die "Could not open $timesFile - $!\n";

my @times = <$fh>;
chomp @times;

# prepopulate the hash
my %aas = map { ($_) => [] } @times;

# now read all the files and add sum the values

foreach my $file ( @files ) {
	warn "Working on $file\n";

	my $fh= IO::File->new();

	$fh->open($file,'<',) or die "Could not open $file - $!\n";

	my @data = <$fh>;
	chomp @data;

	my %aasValues = map { ( (split(/,/))[0] ) =>  [(split(/,/))[1..4]] } @data;

	foreach my $key ( keys %aasValues) {

		# skip the header line
		next if $key eq 'timestamp';
		
		foreach my $i ( 0..3 ) {
			#print "i: $i\n";
			$aas{$key}->[$i] += $aasValues{$key}->[$i] ;
		}

	}
}


foreach my $time ( @times ) {

	print "$time,";

	if ( $aas{$time}->[3] ) { # is there a total?
		printf "%4.1f,%4.1f,%4.1f,%4.1f\n",  @{$aas{$time}};
	} else {
		printf "%4.1f,%4.1f,%4.1f,%4.1f\n", 0,0,0,0;
	}

}



